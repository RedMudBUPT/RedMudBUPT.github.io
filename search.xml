<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前馈神经网络]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[前馈神经网络 (feed-forward nueral network) 前馈神经网络一般有两种，linear perceptron network 和 RBF network，该文主要叙述前一种，其学习规则是梯度下降法，是一种无约束的最优化算法。 NN示例代码 符号及标记 符号 含义 $L$ 代价函数 / 损失函数 / 最优化目标函数 $w$ “轴突”权重 $\sigma$ 神经元“树突”的激活函数 $z$ 带权输入 $z^l=w^{l-1}a^{l-1}$ ，即从上个神经元轴突传到该神经元树突上的值 $a$ 神经元的激活值 $\delta$ 中间变量，称为某层的误差，专用于反向传播算法 注 1：零层为真实数据，尚未前传，自然没有所谓的误差 $\delta$；因第零层的“轴突”上的权重 $w^0$ 尚未学习成功而导致的第一层的神经元的带权输入 $z^1$ 的误差，记为 $\delta^1$ 。 梯度下降法梯度 梯度是个向量，指函数变化增加最快的地方，故沿负梯度的方向便能到达函数的极小值处。 在具体使用时，求得函数在某点（即此时网络的权重值与 loss 函数值）的梯度后，梯度在每一维上的分量值是该函数对该点在该维上的变化率（体现函数增量），函数在哪一维上的变化率越大，该点便在哪一维上距离函数的极点越远，为保证该点在所有维上同时到达函数的极点处，须采用带权步长进行移动（即每一维上的步长大小不一），其具体实现为基础步长（又称学习率）$\alpha$乘上该点的梯度（即函数变化率越大的维上步长越大）。 上段中所说的函数是指理想的函数 $C(\omega)=\frac{1}{n}\sum|y-a|_2$ ，即将无穷个这样的样本点 $(x_1,\dotsb,xm,y){n\to \infty,m&lt;\infty}$ 考虑进去得到的 $C(\omega)$ 。若采样没有噪声，且 $y$ 与 $(x_1,\dotsb,xm)$ 线性相关，则直接采$m$个样本点求解线性方程就能得到参数 $\omega$ 的唯一解。由此可见，我们的方法是用线性函数来逼近非线性函数，构成神经网络后，便是用无数个线性网络的叠加来逼近任意非线性函数。假设激活函数$\sigma(z)=z$，则 $C(\omega,b)=\frac{1}{n}\sum|y-{\omega{L-1}[\omega_{L-2}(\dotsb x)]}|_2$ ，故平常所说的loss函数是与网络结构无关的“基础loss函数”。 反向传播算法$$\delta^l=(w^l\delta^{l+1})*\sigma’_{z^l}\\frac{\partial L}{\partial w^l}=\delta^{l+1}a^l$$ 在用矩阵编程计算梯度时，无需考虑具体矩阵乘积的细节和含义，在得到反向传播的标量表达式后，只需依照两条规则即可写出梯度的矩阵算式： 依据标量表达式确定算式的结构； 依据loss对该层参数偏导的形状调整矩阵的顺序和形状。 SGD待续 常用的激活函数及其对应的 loss 函数线性激活函数与均方差 loss 函数$$\sigma(z)=z\L=\frac{1}{2n}\sum_x||a(x)-y(x)||^2$$ $\delta^L=\frac{1}{n}\sum_x(a-y)$ ； $\delta^l=w^l\delta^{l+1},(l=1,…,L-1)$（因为 $\sigma_z’=1$ ）。 sigmod 激活函数与交叉熵 loss 函数$$\sigma(z)=\frac{1}{1+e^{-z}}\L=-\frac{1}{n}\sum_x[y\ln a+(1-y)\ln (1-a)]$$ $\delta^L=\frac{1}{n}\sum_x(a-y)​$ ； $\delta^l=w^l\delta^{l+1}a^l(1-a^l)$ ，其中“ $*$ ”是Hadamard积。 用交叉熵而非均方差的原因是为了解决神经元饱和问题（指☞神经元因处于$\sigma’(z)$ 值很小的激活值位置而导致的梯度极小，进而带权步长极小的问题）。 对不同的$y$ 用不同的熵，故名为交叉熵，本质为用熵作为 loss 函数，熵越小，不确定信息越少，自然判断结果越可信。个人认为只是为了解决sigmod作为激活函数时导致的神经元饱和问题，与熵的定义没有关系。 该 loss 函数还可通过最大对数似然得到。 综：在目标值为1，而输出值为0的时候，梯度非常大；而当目标值与输出值几乎相等的时候，梯度接近0，模型不发生改变。（待分析） softmax 激活函数与对数似然 loss 函数（right 损失函数）$$\sigma(z_i)=\frac{e^{z_i}}{\sum_ie^{z_i}}\L=-\frac{1}{n}\sum_x\ln a_I,(a_I为真实类别对应神经元的激活值)$$ $\delta^L=\frac{1}{n}\sum_x(a-y)​$ ； $\delta^l=w^l\delta^{l+1}a^l(1-a^l)$ ，其中“ $*$ ”是Hadamard积。 更适用于将输出激活值解释为概率的场景。 设 对该学习算法的优化 在梯度回传的过程中，$\omega$向量可能会变得非常大，则带权步长的移动只会引起在那个方向上微小的变化，以致很难有效地探索各种$\omega$模式。（大分量相对不怎么移动，小分量却相对移动很大，此处相对是指与分量自身相比，故会卡在某个方向上，以致很难有效地探索。）正则化的效果是让网络倾向于学习小一点的权重，让$\omega$只负责方向，而让$b$负责激活空间的位置。 另一个角度是，更小的权重意味着网络的行为不会因为噪声而改变太大，一个无规范化的网络可以使用大的权重来学习包含训练数据中的噪声的大量信息的复杂模型，而规范化的网络受限于根据训练数据中常见的模式来构造相对简单的模型，能够抵抗训练数据中的噪声的影响。 在迭代过程中，还会出现神经元饱和问题，从梯度公式的角度想，是$\sigma’(z)$或$a$过小导致的梯度过小，从而引起学习缓慢的问题，解决方法便是构造合适的函数将梯度公式中的$\sigma’(z)$约掉；从网络的$loss$函数角度想，是寻找极低点时中途出现了原地踱步（小梯度）的情况，解决方法便是选用不同的激活函数与基础$loss$函数的搭配，从而得到形状更好的网络$loss$函数；从模式的可激活空间角度想，是样本$x$在模式$\omega$的激活空间上的分量值（带权输入）处于激活函数的平缓处（极低变化率）导致的模式$\omega$寻找进度迟缓，解决方法便是消除激活函数变化率对模式$\omega$的迭代寻找的影响。 ​]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[numpy概览]]></title>
    <url>%2F2018%2F03%2F08%2Fnumpy%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[术语numpy数据类型 python中的数据类型详解 numpy中自定义的数据类型需用元组表示： 12np.array([[ ( np.array([...]), np.array([...]) ) ]], dtype=[('inputs', 'O'), ('targets', 'O')]) 用[[]]将自定义的数据类型包裹起来的优点是，可用[0,0]的索引方式将object类型的数据解析出来。 ref &gt;&gt; numpy dtype类详解]]></content>
      <categories>
        <category>script</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[感知机学习算法]]></title>
    <url>%2F2018%2F03%2F06%2F%E6%84%9F%E7%9F%A5%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PLA(perceptron learning algorithm) PLA示例代码 线性可分问题中感知机的收敛性 符号 含义 $w_{t}$ 第 t 次错误修正后的权重向量 $(x_t,y_t)$ 第 t 次发现的错误样本点 $w_f$ 真实模式 f 对应的最佳权重向量 有所有样本中的最大长度为$R^2=\max_n||x_n||^2$，设$\rho=\min_n {y_n\frac{w_f^T}{||w_f}x_n}$，则$$wf^Tw{t+1}=w_f^T(wt+y{t+1}x_{t+1})=w_f^Twt+y{t+1}wf^Tx{t+1}\geqslant w_f^Tw_t+\rho ||wf||,\||w{t+1}||^2=||wt+y{t+1}x_{t+1}||^2\leqslant ||w_t||^2+R^2.$$假设找到最佳权重向量需修正错误T次，则由以上两组迭代不等式和初始条件$w_0=0$得到$$w_f^Tw_T\geqslant T\rho ||w_f||,\||w_f^T||^2\leqslant TR^2.$$进而有$$(\frac{w_f^T}{||w_f||}\frac{w_T}{||w_T||})^2\geqslant TC \quad 其中C=\frac{\rho^2}{R^2},为一常量.$$故$T\leqslant \frac{R^2}{\rho^2}$，即对于有限样本的线性可分问题，PLA 收敛。 感知机的学习法则 所谓学习法则，就是权值更新的策略，即在迭代过程中如何进行权值更新。 感知器法则：依照知错就改的演算策略寻找最佳的权重向量（学习到的是各个特征的权重），但若样本线性不可分则不能收敛； $\Delta$法则：用最小二乘法、牛顿迭代法或梯度下降法等最优化方法寻找最小的输出误差（无法说清学习到的是什么，只是冲着最优结果去的），但对于误差曲面被拉长的情况进行学习较为困难。 感知机的局限感知机模式识别只学习特征权重，特征探测器需要手写，即特征需人工提取，故较依赖于人工提取特征的好坏，而该能力较依赖工作者特殊领域的专业经验。由此，发展出了第二代神经网络，即加入了隐藏层，从而实现了特征检测模块的训练，即不但学习特征权重还可以学习特征表示。 注：学习流入 hidden units 的 weight 其实就是学习feature。对于如何表达概念目前有三种观点： 特征论：概念由一系列特征表示，便于解释概念之间的相似性、便于将概念表示为向量； 结构主义论：概念不是孤立的，是关系图谱中的一个节点，由与其它概念的关系决定； 神经网络利用特征向量构成关系图谱：许多神经元表达一个概念，一个神经元同时参与很多个概念的表示，这种多对多的表示被称为“distributed representation”。]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[概率论概览.md]]></title>
    <url>%2F2018%2F03%2F04%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[基本假设为解决贝特朗悖论出现的问题，作以下三点假设（概率论公理）： 样本空间$\Omega$：一个随机实验的所有可能输出的集合； 事件空间$\mathcal{F}$：$\mathcal{F}$为$\Omega$上的$\sigma$代数，是概率论中的定义域；其元素为事件，事件是$\Omega$中某些样本的集合； 测度$P$：$\mathcal{F}$上的测度$P:\mathcal{F}\to R$，是$\sigma$可加且非负的集合函数。 随机变量]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux环境编程基础]]></title>
    <url>%2F2018%2F03%2F01%2Flinux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[内核待续 文件描述符内核为每个进程维护一个文件打开记录表，文件描述符为该文件在表中的索引值。 文件采用引用计数方式访问文件，当引用计数器为零时，内存管理机制便会对其进行垃圾回收。 对于以下选中的情况，引用计数器会自加1： -[x] 创建文件 -[x] 对该文件建立一个硬链接 -[ ] 对该文件建立一个软链接 -[x] 每有一个进程访问该文件 一个文件包括三项，目录项（dentry结构）、索引节点（inode结构）和文件数据。 目录项包括文件名和指向索引节点的指针等信息（当用unlink函数删除该项时，便在该目录中看不见该文件）； 索引节点包括链接数、文件所有者、文件在磁盘的位置等文件属性； 文件数据便是在磁盘上的数据块。 当对该文件建立硬链接（ln src src_ln）时，会额外创建dentry结构和inode结构，但两者的节点号一样（节点号可认为是文件数据的地址）；而当建立符号链接（ln -s src src_ln）时，则是额外创建了一个文本文件，里面包含了源文件的位置信息。两者完全不同，也不能抽象地比较优劣，只能就具体情况来说。 文件系统 实际文件系统（linux为ext文件系统）包括引导块、超级块（记录文件系统的管理信息）、索引节点区（保证了ext文件系统只有一个根节点）和数据区，其中超级块与索引节点区是区分文件系统有无的界限； 虚拟文件系统只存于内存中，它的存在使得操作系统能够兼容足够多的文件系统，具体是将其他文件系统进行封装，并挂载到ext文件系统的目录树下，以使得内核能够以一致的方式访问其他文件系统； 特殊文件系统proc，也只存于内存中，是内核的窗口，用于查看内核运行的实时信息。 库 在编译链接的过程中，链接器搜索静态库（archives）时会链接所有已引用却未处理的符号，而未引用或已处理的符号不会从静态库中链接出来，故链接库的链接位置应放置在命令行尾部，否则会出现符号未处理的情况； 调用动态库的方式类似于对数据文件的读取，故只有在程序执行时才会装入内存，注意编译链接时须有链接选项-ldl； 创建静态库的命令为ar cr libtest.a test1.o test2.o，编译成动态库的命令为g++ -share -fPIC -o libtest.so test1.o test2.o。 因为c不支持函数重载（即与c++函数签名方式不同），所以在c/c++混合编程时，须用extern “c” {}将c代码封装。 僵尸进程在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等，但是仍然为其保留一定的信息(包括进程号，退出状态，运行时间等)， 只有父进程通过wait/waitpid来取时才释放，否则其进程号就会一定被占用，这样就导致了僵尸进程的问题。]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线性代数review]]></title>
    <url>%2F2018%2F02%2F28%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[对矩阵乘积的各种viewpoint 列向量的inner product $ x^Ty $ ：n个元素之积的和 列向量的outer product $xy^T$： 对两个列向量各元素之积的陈列【主】； 对列向量$x$分别进行n次倍乘的并行运算，并堆叠成一个矩阵。 矩阵向量之积$Ax$： 1个列向量分别与n个列向量的inner product的并行运算（将$A$看做行向量的堆叠）【主】； 对n个列向量的线性组合，即对n个列向量各赋予不同权重后的组合（将$A$看做列向量的堆叠）。 矩阵矩阵之积$AB$： n组列向量的outer product的和，即n个矩阵（每组矩阵为一组列向量的outer producter）的和（$A$ by columns, $B$ by rows）【主】； 应用：反向传播、方差 n个列向量分别进行矩阵向量之积$Ab$的并行运算； 对两个矩阵各列向量的inner product的陈列【多用于结合标量的性质进行证明矩阵性质的证明】。 矩阵的一些性质迹 满足交换性和轮换性：$\mathrm{tr}AB=\mathrm{tr}BA$，$\mathrm{tr}ABC=\mathrm{tr}CAB=\mathrm{tr}BCA$ 范数 把线性空间的一个元素（向量、矩阵、……）与一个非负实数相联系，在许多场合下，这个非负实数可以作为向量或者矩阵大小的一种度量，这个非负实数便称为范数（当说长度时，特指的是内积空间中向量的2-范数）。元素与实数的映射关系需满足4点才能称为范数：非负性、定性、齐次性和三角不等式。 范数分类：p-范数、加权范数（$||x||_A=\sqrt{x^TAx}$）、F-范数（$\sqrt{\mathrm{tr}(A^TA)}$）、…… 矩阵的列空间与零空间 $L(x_1,x_2)$意为向量$x_1$与$x_2$张成的空间； $R(A)$ 意为矩阵$A$的列向量张成的空间，称为$A$的列空间或$A$的值域； $R(A)^{\bot}$意为 $A$的列空间的正交补空间； $N(A)$意为$A$的零空间或$A$的核空间。 $A$的零空间是$A^T$的列空间的正交补空间，而A^T的列空间维度与A的列空间维度在数量上相等，故$\mathrm{dim}N(A)=\mathrm{dim}R(A^T)^{\bot}=\mathrm{dim}R(A)^{\bot}=n-rank(A)$，为简化书写与推导，常一步写为$\mathrm{dim}N(A)=n-rank(A)$。 行列式 一种几何上的解释：$\mathrm{abs}|A|$ 意为矩阵$A$的行向量限制性地张成的空间的体积。（限制性地张成，是指用于线性组合的系数在(0,1)间取值。） $|AB|=|A||B|$ $|A^{-1}|=\frac{1}{|A|}$ 如果$A$奇异，那么$A$的行向量线性相关，限制性地张成的空间是n维空间中的“flat sheet”，故此时$|A|=0$。 二次型与矩阵的定性 n个变量的二次多项式（每一项的次数都为2的多项式）称为二次型。矩阵形式的二次型为一标量$x^TAx$，其中$A$称为二次型矩阵，虽然无论$A$是否对称，$x^TAx$总是一个二次型，但A的表现形式（是否对称）并不影响这个标量的结果，故若无特殊说明，默认二次型矩阵为一对称阵。 根据二次型的正负，将矩阵分为正定阵（PD）、半正定阵（PSD）、负定阵（ND）、半负定阵（NSD）和不定阵。 度量阵$A^TA$必为半正定，若$A$的形状为“$\mathrm{I}$“，且列满秩，则该矩阵必正定。 矩阵的特征向量与特征值 默认特征向量特指单位化的特征向量（虽然因为有正负还是不唯一，但已足够）。 $\mathrm{tr}A=\sum_{i=1}^n\lambda_i$ $|A|=\prod_{i=1}^n\lambda_i$ 对称阵的特征向量与特征值 对称阵的特征值均为实数，特征向量两两正交。 若对称阵的特征值均为正数则必正定（由对称阵必能正交对角化推得），依此类推。 针对最优化问题$$\mathrm{min}x^TAx \quad s.t. ||x||_2^2=1$$结果为$A$的最小特征值，$x$为其对应的特征向量。因为$A$为对称阵，故能正交对角化$A=U\Lambda U^T$，原问题便转化为了：将原默认基换为$U$的列向量构成的基，于是$x$便成为了$y$，满足$y=U^{-1}x$ （其过程为$x$向$U$的各个列向量方向投影，并依列向量次序组织成为$y$），因为$U$为正交阵，故$||y||_2^2=1$依然成立，与此同时，优化目标变为$\mathrm{min}y^T\Lambda y$，可看做（问题本质并非这样，但脱离问题只就该式子的数学形式来看可如此看待；这种办法只可用于求解不能用于理解）在度量矩阵$\Lambda$下求单位向量$y$的方向，故得解。 线性变换正交阵，对称阵与投影阵矩阵微积分]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[makefile基础]]></title>
    <url>%2F2018%2F02%2F20%2Fmakefile%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[文件基本格式12target:prerequisites[tab] commands 若prerequisites中有一个文件比target文件新，则执行commands所定义的命令。若显式指明target为伪目标，即.PHONY:target，则make命令将跳过文件检查，直接执行对应的命令，由此避免了因当前目录下有target文件而不会执行命令的问题。 若make未指定目标则缺省执行第一个目标。 命令按行解析，每行命令都在单独的进程中执行。 在[tab]后commands前添加@，可关闭回显，常用于echo命令。 include filename命令可将其他文件包含进来，若在该命令行首添加-，表示忽略可能会出现的文件包含错误。 变量 变量在使用时展开，形式上类似宏替换，如此引用$(var)，而引用shell变量时用$$。 变量定义的四种格式： var=value在执行时才扩展 var:=value在定义时便扩展，直接使用右侧的现值 var?=value若变量为空则设置该值，否则维持原值 var+=value将值追加到变量尾部，继承上次的操作符，若未定义过则自动解释为=特殊变量 内置变量$(CC)当前使用的编译器 $(MAKE)当前使用的make工具 自动变量 $@当前目标 $^所有先决条件，$?比目标更新的所有先决条件。 $&lt;第一个先决条件 多行变量123define var commandsendef 主要用于定义命令包，每行命令都在单独的进程中执行，故展开时有可能导致脚本错误。 静态模式：以%通配12345objs=main.o library.oall:$(objs) $(cc) -o a $(objs)$(objs):%.o:%.c $(CC) -c $&lt; -o $@ 条件判断基本格式12345conditional-directive commandselse commandsendif 可用的条件判断 ifeq(var1,var2) 两参数是否相等 ifneq(var1,var2) 两参数是否不等 ifdef var 变量是否已定义 ifndef var 变量是否未定义 循环可使用shell循环123456objs = file1 file2rulefor: for filename in `echo $(objs)`; \ do \ touch $$filename; \ done \保证了多行命令在同一进程下执行，因命令是在shell下执行的，故filename为shell变量，自然用$$引用。 字符串替换函数示例123456789comma := ,empty := space := $(empty) $(empty)str1 := a b cstr2 := $(subst $(space),$(comma),$(str))result: @echo $(str1) @echo $(str2) @echo "done"]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mc文件管理器命令备忘]]></title>
    <url>%2F2018%2F02%2F20%2Fmc%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[文件信息查看与修改1234C-x i 显示文件详细信息，重复指令关闭窗口（类似stat命令）C-u 左右面板互换（用于改变列表显示模式）C-x c 修改文件权限信息（space为反选键）[alt]-t 切换列表显示模式 快捷访问：1234C-x h 添加文件至收藏夹C-\ 显示文件收藏夹列表[tab] 切换活动面板C-s 在当前目录下查找文件 文件移动与管理1234+ 可用正则匹配符选中多个文件- 取消选中[insert] 多选模式下反选当前高亮文件F-5,6,8 对当前高亮文件或选中的多个文件进行复制、更名或移动、删除操作，目标为另一个面板所在路径 命令行123C-w 删除光标前所有字符C-b C-f C-a C-e 移动光标（方向键在此不起作用）[esc] [tab] 命令补全（重复两次会显示补全列表） 辅助指令12[esc] 1 帮助手册C-o 与父shell进行切换（切换后父shell工作目录为活动面板工作目录，用于更多的shell指令） 主题倾向1yadt256]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LaTex简易教程]]></title>
    <url>%2F2017%2F12%2F15%2FLaTex%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第一章文章结构控制 建立整体框架：1234567891011\documentclass&#123;article&#125; \begin&#123;document&#125;\section&#123;第一节&#125;\label&#123;sec:sec_1&#125;\section&#123;第二节&#125;\label&#123;sec:sec_2&#125; \subsection&#123;第二节第一子节&#125; \label&#123;sec:sec_2_1&#125; something...\end&#123;document&#125; 公式控制 段落内公式： 1something...$X$ somthing... something…$X$ somthing… 独立于段落外的公式： 123\[\Delta f\approx (\nabla f, \nabla X)\] $$ \Delta f\approx (\nabla f, \nabla X) $$ 公式对齐控制： 1234\begin&#123;align*&#125;\frac&#123;\partial&#123;\mathrm&#123;f&#125;&#125;&#125;&#123;\partial&#123;x&#125;&#125; &amp;= \frac&#123;\partial&#123;f&#125;&#125;&#123;\partial&#123;x^T&#125;&#125;, \\\nabla_x\mathrm&#123;f&#125; &amp;= \nabla_&#123;x^T&#125;f.\end&#123;align*&#125; $$ \frac{\partial{\mathrm{f}}}{\partial{x}} = \frac{\partial{f}}{\partial{x^T}}, $$ 列表控制：1234\begin&#123;enumerate&#125; \item 第一项 \item 第二项\end&#123;enumerate&#125; 或者 1234\begin&#123;itemize&#125; \item 第一项 \item 第二项\end&#123;itemize&#125; 后记：实用工具LaTex编译环境使用sharelatex即可。当使用中文时，建议用XeLaTex进行build。 LaTex特殊符号的查询可使用Detexify工具得到特殊符号的LaTex语法。 公式编辑的实时显示可使用Markdown-MathJax-editor-online工具检查公式语法的正确性。 ref: LaTex 完整教程]]></content>
      <categories>
        <category>script</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell中括号使用总结]]></title>
    <url>%2F2017%2F08%2F14%2Fshell%E4%B8%AD%E6%8B%AC%E5%8F%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[${var}限定变量名称范围 1234#!/bin/sh# test.shvar=testecho $&#123;var&#125;12 效果如下 12$ ./test.sh$ var12 $(cmd)命令替换 123#!/bin/sh# test.shecho $(ls) 运行效果与 ls 相同 {}或()一串命令的执行 1234$ &#123; echo 1;echo "A";&#125; &gt; tmp$ cat ./tmp$ 1$ A ${var:-string},${var:+string},${var:=string},${var:?string}几种特殊的替换结构 ${var:-string}若var为空，则结果为&quot;string&quot;，否则结果为$var。 ${var:=string}若var为空，则结果为&quot;string&quot;，并将该字符串赋给var，否则结果为$var。 ${var:+string}若var不为空，则结果为&quot;string&quot;，否则结果为$var。 ${var:?string}若var不为空，则结果为$var，否则将&quot;string&quot;输出到标准错误中，并从脚本退出。 $((exp))POSIX标准的扩展计算，只要符合C的运算符都可用在$((exp))，甚至是三目运算符。 ${var%pattern},${var%%pattern},${var#pattern},${var##pattern}四种模式匹配替换结构 []或[[]]类似test ()在子shell中运行 {}{1..30} 就是1-30，或者是/{,s}bin/表示/bin/和/sbin/，ab{c,d,e}表示abc、abd、abe reference]]></content>
      <categories>
        <category>script</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简要剖析linux操作系统下执行一个程序的原理]]></title>
    <url>%2F2017%2F05%2F21%2F%E7%AE%80%E8%A6%81%E5%89%96%E6%9E%90linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%9E%E4%BE%8B%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[预备知识 程序只是一段代码，独立的程序没有任何实际意义，只有将它置于一定的环境（上下文）内才有其意义。比如说，一个用C#写成的一段hello world代码在windows环境下编译生成的一个程序文件，将它放在ARM机里，在它实例化之前（即执行前），它与ARM机里其他可以执行的程序是一样的，只是一个占据着一定内存空间的二进制文件；一旦将这些二进制文件执行，实例化后产生的东西（称为进程）便具有了实际意义，即这个进程所能实现的功能，当然前提是它能在该环境中实例化，前面所提的C#程序文件便不能在ARM机中实例化。 综上，程序可认为是进程的抽象，一个程序可以实例化出任意多个进程。 linux系统中所有的进程都是在0号进程的基础上fork生成的，故在开机后，运行的任何一个程序都是在某个程序的基础上fork生成后继而执行的。 因此，若要分析执行一个程序的原理，可用任意一个具体的例子进行说明，其中关键性部分几乎不会存在差异。 例子以在shell中执行ls命令为例，进行说明。 预备知识1——简易“子栈”建立“子栈”的概念。从一个函数A跳转到另一个函数B时会创建一个临时堆栈，称函数A所在的堆栈为父栈，称函数B所在的堆栈为子栈。在一个子栈中运行的基本框架如下所示： 12345pushl %ebp /*enter*/ //保存父栈环境movl %esp %ebp //新建子栈环境...movl %ebp %esp /*leave*/ //恢复父栈环境popl %ebp //恢复父栈环境 note: push和pop都是依sp寻址的。 为深入理解该框架，要明确以下几点： 首先要明确一个CPU在某一确定的时刻只能运行在一个堆栈空间中，当建立起子栈后，CPU便已运行在了子栈中，当前起作用的堆栈空间便是子栈，而当CPU离开子栈后，起作用的堆栈空间便成了父栈，且方才用过的子栈不复存在，即永远也不可能再次回到方才起作用的子栈，但能再次创建一个新的子栈。这也是将子栈称为临时堆栈、子函数的变量称为临时变量的原因。从根本上来看，除最初开机时建立的堆栈外，所有的堆栈都是临时堆栈，而子父关系便是相对而言。 其次由该框架可发现简易子栈与父栈在地址空间上是连续的,而若将子栈动态信息另存于系统中以实现再次寻回时（见正文），其框架只是加入了对子栈动态信息的保存和重载（因为子栈与父栈在地址空间上不再连续。而无法连续的原因是从子栈返回父栈后，子栈的数据极有可能被覆盖。所以连续的前提是确保子栈不会被第二次使用）。 最后要明确正文中的堆栈之间实际上不是父子关系，而是平等的。依然采用子栈、父栈的名称是为了结合该简易子栈的框架方便理解。依据时间顺序，称后创建的为子栈。 预备知识2——GCC内联汇编基本格式：1234567asm volatile( 汇编语句模板: 输出部分: 输入部分: 破坏描述部分);//即格式为asm("statements":output_regs:input_regs:clobbered_regs); 常用寄存器加载代码说明:|代码|说明||-|:-||a|使用寄存器eax||b|使用寄存器ebx||c|使用寄存器ecx||d|使用寄存器edx||m|使用内存地址||o|使用内存地址并可以加偏移值||r|使用任意动态分配的寄存器||+|表示操作数可读可写||=|输出操作数，输出值将替换前值| 预备知识3——ELF文件待续 正文若将之前所述的子栈的信息保存在系统中，便可实现在运行于某子栈环境中的进程退出前，总是能够再次找到该子栈。可采用类似于如下的结构实现子栈信息的保存：1234struct Thread &#123; unsigned long ip; unsigned long sp;&#125;; 由此，对于进程，可用如下结构进行描述：123456789struct PCB&#123; int pid; unsigned long task_entry; //进程入口点 char stack[STACK_SIZE]; volatile long state; struct Thread thread; struct PCB *next;&#125;; 运行一个进程基本需要以下第三步： 创建0号进程： 123456789asm volatile( "movl %1,%%esp\n\t" "pushl %1\n\t" //将0号进程栈底指针压栈 "movl %1,%%ebp\n\t" "pushl %0\n\t" "ret\n\t" //启动0号进程 : :"c"(task[0].thread.ip),"d"(task[0].thread.sp)); 调度到一个尚未创建栈环境的进程x（即，创建子栈）： 1234567891011asm volatile( "pushl %%ebp\n\t" /*保存父栈环境*/ "movl %%esp,%0\n\t" "movl $1f,%1\n\t" "movl %2,%%ebp\n\t" /*新建子栈环境*/ "movl %2,%%esp\n\t" "pushl %3\n\t" /*启动x号进程*/ "ret\n\t" :"=m"(task[NOW]-&gt;thread.sp),"=m"(task[NOW]-&gt;thread.ip) :"m"(task[x]-&gt;thread.sp),"m"(task[x]-&gt;thread.ip)); 调度到已经存在栈环境（即，至少运行过一次）的进程x（即，切换栈环境）： 123456789101112asm volatile( "pushl %%ebp\n\t" /*保存父栈环境*/ "movl %%esp,%0\n\t" "movl $1f,%1\n\t" "movl %2,%%esp\n\t" /*切换栈环境*/ "pushl %3\n\t" /*切换至x号进程*/ "ret\n\t" "1:\t" //下条指令的地址即为$1f对应的地址 "popl %%ebp\n\t" //此处pop出的是上次x进程被切换出去时push进去的ebp :"=m"(task[NOW]-&gt;thread.sp),"=m"(task[NOW]-&gt;thread.ip) :"m"(task[x]-&gt;thread.sp),"m"(task[x]-&gt;thread.ip)); 结合以上三点，便可总结调度器切换进程的简要步骤（省略进程的优先级策略等）： 保存栈环境：进程断点压栈（编译器自动生成该指令），进程栈底指针压栈，保存进程栈顶指针，并保存恢复栈环境指令的首地址$1f。 转移栈环境：给栈顶指针赋值，并弹出新进程栈底指针和断点。 假设可执行文件是静态链接的（不考虑共享库），实例一个程序只需将程序的文本段、数据段、bss段和堆栈段映射到进程线性区，然后结合上述的第二点，调度到这个尚未创建栈环境的进程，之后只运行上述的第三点即可，从而便实现了对一个程序的实例化。 附：fork()返回两次的本质待续 refernece0: C语言ASM汇编内嵌语法zz reference1: linux内核分析]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim-使用教程]]></title>
    <url>%2F2017%2F05%2F05%2Fvim-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vim 插件配置安装vim123456$ git clone git@github.com:vim/vim.git$ cd vim/$ sudo apt install python-dev python3-dev ruby-dev libtolua-dev libx11-dev libghc-gtk-dev libghc-gtk3-dev python-gtk2-dev libghc-ncurses-dev$ ./configure --with-features=huge --enable-pythoninterp --enable-rubyinterp --enable-luainterp --enable-perlinterp --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu/ --enable-gui=gtk2 --enable-cscope --prefix=/usr$ make$ make install more infoUbuntu Packages Search 安装 vundle1$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim .vimrc 文件配置参考 .vimrc 安装插件进入vim执行：123:PluginInstall:PluginClean #卸载前先删掉.vimrc文件中的配置语句:PluginUpdate 安装YCM插件1234$ sudo apt-get install llvm-dev clang$ sudo apt install cmake$ cd ~/.vim/bundle/YouCompleteMe$ ./install.py --clang-completer --system-libclang more infouse vim as IDE gvim 的使用工程环境配置修改~/.indexer_files 用于产生标签 123--------------- ~/.indexer_files --------------- [project] /home/redmud/practice/project/src/ 根据你工程情况只需调整 .ycm_extra_conf.py 的 flags 部分 参考.ycm_extra_conf.py 快捷键的使用1234567891011121314151617181920212223242526;ilt #打开标签页;hw #跳转左侧窗口p #右侧窗口显示标签对应函数/word #在文件内查找关键字;sp #在工程内查找关键字&lt;CR&gt; #进入关键字对应文件p #暂时在右侧显示对应文件q #退出u #撤销上步操作 ctl+r #撤销上步的撤销;ud #显示撤销树;;fx #跳至x字符;cc #注释;cu #取消注释;rw #在文件内不确认得全文替换单词mx #设定/取消该行为标签xm, #自动设定一个可用书签名mn #跳转至下个书签mda #删除当前文件所有书签ctl+o #跳回上次鼠标位置]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+gitpage搭建个人博客（ubuntu16.04环境）]]></title>
    <url>%2F2017%2F05%2F05%2F%E4%BD%BF%E7%94%A8hexo%2Bgitpage%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(ubuntu16.04%E7%8E%AF%E5%A2%83)%2F</url>
    <content type="text"><![CDATA[博客搭建安装npm nodejs git hexo工具1234$ sudo apt-get install npm$ sudo apt-get install nodejs$ sudo apt-get install git$ npm install -g hexo 创建博客文件夹123$ hexo init BLOG #假设为BLOG$ cd BLOG$ npm install #安装依赖 主题更改123456$ hexo clean$ git clone https://github.com/iissnan/hexo-theme-next themes/next$ cd themes/next$ git pull$ hexo generate$ hexo server 现在打开http://localhost:4000/ ，就发现新的主题安装成功了。按ctl+c退出 创建git仓库[图] 配置1234$ cd BLOG$ git config --global user.name "username" # username为你自己的github用户名$ git config --global user.email "email@example.com"$ ssh-keygen -t rsa -C "email@example.com" 为github仓库添加SSH keys（id_rsa.pub）12345$ git init$ git add README.md$ git commit -m "first commit"$ git remote add origin git@github.com:"username"/"username".github.io.git #关联远程仓库$ git push -u origin master More info: git command 修改BLOG目录下的_config.yml文件1234deploy: type: github repo: git@github.com:"username"/"username".github.io.git branch: master 安装一个Hexo的插件1$ npm install hexo-deployer-get --save 修改BLOG目录下的_config.yml文件1234deploy: type: git repo: git@github.com:"username"/"username".github.io.git branch: master hexo部署12$ hexo generate$ hexo deploy 浏览 打开网页https://“username”.github.io 后期使用创建新的post,并生效1234$ hexo new "MyNewPost"$ gedit source/_posts/MyNewPost.md$ hexo generate$ hexo deploy 全局配置 _config.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration## Docs: http//hexo.io/docs/configuration.html## Source: https//github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http//momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: 刚刚github创库地址.git branch: master More info: reference2]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 使用教程]]></title>
    <url>%2F2017%2F05%2F04%2Fgit-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[使用ssh背景 用作认证的私钥最好通过passphrase进行加密，否则会有很大安全隐患，只要私钥泄露，别人就能访问你能访问的所有远程机器，不过每次登陆都得输入passphrase。 ssh-agent启动后，可通过ssh-add将私钥加入agent，使用ssh-agent后，只需在将key纳入agent管理时输入passphrase，之后的ssh相关操作就不必输入passphrase了。如果ssh-agent中有多个私钥, 会依次尝试，直到认证通过或遍历所有私钥。 more infoSSH Agent Forwarding原理An Illustrated Guide to SSH Agent Forwarding 指令12345$ ssh-kengen -t rsa -C "some words(email usually)"$ ssh-agent -s$ ssh-add ~/.ssh/id-rsa #添加私钥$ ssh-add ~/.ssh/id-rsa2$ vim ~/.ssh/config config 文件类似如下123456789Host redmudbupt.github.com HostName github.com IdentityFile /home/redmud/.ssh/id_rsa User git host bkseastone.github.com HostName github.com IdentityFile /home/redmud/.ssh/id_rsa2 User git 应用123$ git remote add origin git@bkseastone.github.com:bkseastone/lab_test.git #添加远程库$ git config user.name "one_name" $ git config user.email "one_email" #给仓库设置局部用户名和邮箱 git 使用 more infogit command]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
</search>
