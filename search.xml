<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用hexo+gitpage搭建个人博客（ubuntu16.04环境）]]></title>
    <url>%2F2018%2F02%2F20%2F%E4%BD%BF%E7%94%A8hexo%2Bgitpage%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(ubuntu16.04%E7%8E%AF%E5%A2%83)%2F</url>
    <content type="text"><![CDATA[博客搭建安装npm nodejs git hexo工具1234$ sudo apt-get install npm$ sudo apt-get install nodejs$ sudo apt-get install git$ npm install -g hexo 创建博客文件夹123$ hexo init BLOG #假设为BLOG$ cd BLOG$ npm install #安装依赖 主题更改123456$ hexo clean$ git clone https://github.com/iissnan/hexo-theme-next themes/next$ cd themes/next$ git pull$ hexo generate$ hexo server 现在打开http://localhost:4000/ ，就发现新的主题安装成功了。按ctl+c退出 创建git仓库[图] 配置1234$ cd BLOG$ git config --global user.name "username" # username为你自己的github用户名$ git config --global user.email "email@example.com"$ ssh-keygen -t rsa -C "email@example.com" 为github仓库添加SSH keys（id_rsa.pub）12345$ git init$ git add README.md$ git commit -m "first commit"$ git remote add origin git@github.com:"username"/"username".github.io.git #关联远程仓库$ git push -u origin master More info: git command 修改BLOG目录下的_config.yml文件1234deploy: type: github repo: git@github.com:"username"/"username".github.io.git branch: master 安装一个Hexo的插件1$ npm install hexo-deployer-get --save 修改BLOG目录下的_config.yml文件1234deploy: type: git repo: git@github.com:"username"/"username".github.io.git branch: master hexo部署12$ hexo generate$ hexo deploy 浏览 打开网页https://“username”.github.io 后期使用创建新的post,并生效1234$ hexo new "MyNewPost"$ gedit source/_posts/MyNewPost.md$ hexo generate$ hexo deploy 全局配置 _config.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration## Docs: http//hexo.io/docs/configuration.html## Source: https//github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http//momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: 刚刚github创库地址.git branch: master More info: reference2]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[makefile基础]]></title>
    <url>%2F2018%2F02%2F20%2Fmakefile%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[文件基本格式12target:prerequisites[tab] commands 若prerequisites中有一个文件比target文件新，则执行commands所定义的命令。若显式指明target为伪目标，即.PHONY:target，则make命令将跳过文件检查，直接执行对应的命令，由此避免了因当前目录下有target文件而不会执行命令的问题。 若make未指定目标则缺省执行第一个目标。 命令按行解析，每行命令都在单独的进程中执行。 在[tab]后commands前添加@，可关闭回显，常用于echo命令。 include filename命令可将其他文件包含进来，若在该命令行首添加-，表示忽略可能会出现的文件包含错误。 变量 变量在使用时展开，形式上类似宏替换，如此引用$(var)，而引用shell变量时用$$。 变量定义的四种格式： var=value在执行时才扩展 var:=value在定义时便扩展，直接使用右侧的现值 var?=value若变量为空则设置该值，否则维持原值 var+=value将值追加到变量尾部，继承上次的操作符，若未定义过则自动解释为=特殊变量 内置变量$(CC)当前使用的编译器 $(MAKE)当前使用的make工具 自动变量 $@当前目标 $^所有先决条件，$?比目标更新的所有先决条件。 $&lt;第一个先决条件 多行变量123define var commandsendef 主要用于定义命令包，每行命令都在单独的进程中执行，故展开时有可能导致脚本错误。 静态模式：以%通配12345objs=main.o library.oall:$(objs) $(cc) -o a $(objs)$(objs):%.o:%.c $(CC) -c $&lt; -o $@ 条件判断基本格式12345conditional-directive commandselse commandsendif 可用的条件判断 ifeq(var1,var2) 两参数是否相等 ifneq(var1,var2) 两参数是否不等 ifdef var 变量是否已定义 ifndef var 变量是否未定义 循环可使用shell循环123456objs = file1 file2rulefor: for filename in `echo $(objs)`; \ do \ touch $$filename; \ done \保证了多行命令在同一进程下执行，因命令是在shell下执行的，故filename为shell变量，自然用$$引用。 字符串替换函数示例123456789comma := ,empty := space := $(empty) $(empty)str1 := a b cstr2 := $(subst $(space),$(comma),$(str))result: @echo $(str1) @echo $(str2) @echo "done"]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mc文件管理器命令备忘]]></title>
    <url>%2F2018%2F02%2F20%2Fmc%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[文件信息查看与修改1234C-x i 显示文件详细信息，重复指令关闭窗口（类似stat命令）C-u 左右面板互换（用于改变列表显示模式）C-x c 修改文件权限信息（space为反选键）[alt]-t 切换列表显示模式 快捷访问：1234C-x h 添加文件至收藏夹C-\ 显示文件收藏夹列表[tab] 切换活动面板C-s 在当前目录下查找文件 文件移动与管理1234+ 可用正则匹配符选中多个文件- 取消选中[insert] 多选模式下反选当前高亮文件F-5,6,8 对当前高亮文件或选中的多个文件进行复制、更名或移动、删除操作，目标为另一个面板所在路径 命令行123C-w 删除光标前所有字符C-b C-f C-a C-e 移动光标（方向键在此不起作用）[esc] [tab] 命令补全（重复两次会显示补全列表） 辅助指令12[esc] 1 帮助手册C-o 与父shell进行切换（切换后父shell工作目录为活动面板工作目录，用于更多的shell指令） 主题倾向1yadt256]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LaTex简易教程]]></title>
    <url>%2F2017%2F12%2F15%2FLaTex%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第一章文章结构控制 建立整体框架：1234567891011\documentclass&#123;article&#125; \begin&#123;document&#125;\section&#123;第一节&#125;\label&#123;sec:sec_1&#125;\section&#123;第二节&#125;\label&#123;sec:sec_2&#125; \subsection&#123;第二节第一子节&#125; \label&#123;sec:sec_2_1&#125; something...\end&#123;document&#125; 公式控制 段落内公式： 1something...$X$ somthing... something…$X$ somthing… 独立于段落外的公式： 123\[\Delta f\approx (\nabla f, \nabla X)\] $$ \Delta f\approx (\nabla f, \nabla X) $$ 公式对齐控制： 1234\begin&#123;align*&#125;\frac&#123;\partial&#123;\mathrm&#123;f&#125;&#125;&#125;&#123;\partial&#123;x&#125;&#125; &amp;= \frac&#123;\partial&#123;f&#125;&#125;&#123;\partial&#123;x^T&#125;&#125;, \\\nabla_x\mathrm&#123;f&#125; &amp;= \nabla_&#123;x^T&#125;f.\end&#123;align*&#125; $$ \frac{\partial{\mathrm{f}}}{\partial{x}} = \frac{\partial{f}}{\partial{x^T}}, $$ 列表控制：1234\begin&#123;enumerate&#125; \item 第一项 \item 第二项\end&#123;enumerate&#125; 或者 1234\begin&#123;itemize&#125; \item 第一项 \item 第二项\end&#123;itemize&#125; 后记：实用工具LaTex编译环境使用sharelatex即可。当使用中文时，建议用XeLaTex进行build。 LaTex特殊符号的查询可使用Detexify工具得到特殊符号的LaTex语法。 公式编辑的实时显示可使用Markdown-MathJax-editor-online工具检查公式语法的正确性。 ref: LaTex 完整教程]]></content>
      <categories>
        <category>script</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell中括号使用总结]]></title>
    <url>%2F2017%2F08%2F14%2Fshell%E4%B8%AD%E6%8B%AC%E5%8F%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[${var}限定变量名称范围 1234#!/bin/sh# test.shvar=testecho $&#123;var&#125;12 效果如下 12$ ./test.sh$ var12 $(cmd)命令替换 123#!/bin/sh# test.shecho $(ls) 运行效果与 ls 相同 {}或()一串命令的执行 1234$ &#123; echo 1;echo "A";&#125; &gt; tmp$ cat ./tmp$ 1$ A ${var:-string},${var:+string},${var:=string},${var:?string}几种特殊的替换结构 ${var:-string}若var为空，则结果为&quot;string&quot;，否则结果为$var。 ${var:=string}若var为空，则结果为&quot;string&quot;，并将该字符串赋给var，否则结果为$var。 ${var:+string}若var不为空，则结果为&quot;string&quot;，否则结果为$var。 ${var:?string}若var不为空，则结果为$var，否则将&quot;string&quot;输出到标准错误中，并从脚本退出。 $((exp))POSIX标准的扩展计算，只要符合C的运算符都可用在$((exp))，甚至是三目运算符。 ${var%pattern},${var%%pattern},${var#pattern},${var##pattern}四种模式匹配替换结构 []或[[]]类似test ()在子shell中运行 {}{1..30} 就是1-30，或者是/{,s}bin/表示/bin/和/sbin/，ab{c,d,e}表示abc、abd、abe reference]]></content>
      <categories>
        <category>script</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简要剖析linux操作系统下执行一个程序的原理]]></title>
    <url>%2F2017%2F05%2F21%2F%E7%AE%80%E8%A6%81%E5%89%96%E6%9E%90linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%9E%E4%BE%8B%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[预备知识 程序只是一段代码，独立的程序没有任何实际意义，只有将它置于一定的环境（上下文）内才有其意义。比如说，一个用C#写成的一段hello world代码在windows环境下编译生成的一个程序文件，将它放在ARM机里，在它实例化之前（即执行前），它与ARM机里其他可以执行的程序是一样的，只是一个占据着一定内存空间的二进制文件；一旦将这些二进制文件执行，实例化后产生的东西（称为进程）便具有了实际意义，即这个进程所能实现的功能，当然前提是它能在该环境中实例化，前面所提的C#程序文件便不能在ARM机中实例化。 综上，程序可认为是进程的抽象，一个程序可以实例化出任意多个进程。 linux系统中所有的进程都是在0号进程的基础上fork生成的，故在开机后，运行的任何一个程序都是在某个程序的基础上fork生成后继而执行的。 因此，若要分析执行一个程序的原理，可用任意一个具体的例子进行说明，其中关键性部分几乎不会存在差异。 例子以在shell中执行ls命令为例，进行说明。 预备知识1——简易“子栈”建立“子栈”的概念。从一个函数A跳转到另一个函数B时会创建一个临时堆栈，称函数A所在的堆栈为父栈，称函数B所在的堆栈为子栈。在一个子栈中运行的基本框架如下所示： 12345pushl %ebp /*enter*/ //保存父栈环境movl %esp %ebp //新建子栈环境...movl %ebp %esp /*leave*/ //恢复父栈环境popl %ebp //恢复父栈环境 note: push和pop都是依sp寻址的。 为深入理解该框架，要明确以下几点： 首先要明确一个CPU在某一确定的时刻只能运行在一个堆栈空间中，当建立起子栈后，CPU便已运行在了子栈中，当前起作用的堆栈空间便是子栈，而当CPU离开子栈后，起作用的堆栈空间便成了父栈，且方才用过的子栈不复存在，即永远也不可能再次回到方才起作用的子栈，但能再次创建一个新的子栈。这也是将子栈称为临时堆栈、子函数的变量称为临时变量的原因。从根本上来看，除最初开机时建立的堆栈外，所有的堆栈都是临时堆栈，而子父关系便是相对而言。 其次由该框架可发现简易子栈与父栈在地址空间上是连续的,而若将子栈动态信息另存于系统中以实现再次寻回时（见正文），其框架只是加入了对子栈动态信息的保存和重载（因为子栈与父栈在地址空间上不再连续。而无法连续的原因是从子栈返回父栈后，子栈的数据极有可能被覆盖。所以连续的前提是确保子栈不会被第二次使用）。 最后要明确正文中的堆栈之间实际上不是父子关系，而是平等的。依然采用子栈、父栈的名称是为了结合该简易子栈的框架方便理解。依据时间顺序，称后创建的为子栈。 预备知识2——GCC内联汇编基本格式：1234567asm volatile( 汇编语句模板: 输出部分: 输入部分: 破坏描述部分);//即格式为asm("statements":output_regs:input_regs:clobbered_regs); 常用寄存器加载代码说明:|代码|说明||-|:-||a|使用寄存器eax||b|使用寄存器ebx||c|使用寄存器ecx||d|使用寄存器edx||m|使用内存地址||o|使用内存地址并可以加偏移值||r|使用任意动态分配的寄存器||+|表示操作数可读可写||=|输出操作数，输出值将替换前值| 预备知识3——ELF文件待续 正文若将之前所述的子栈的信息保存在系统中，便可实现在运行于某子栈环境中的进程退出前，总是能够再次找到该子栈。可采用类似于如下的结构实现子栈信息的保存：1234struct Thread &#123; unsigned long ip; unsigned long sp;&#125;; 由此，对于进程，可用如下结构进行描述：123456789struct PCB&#123; int pid; unsigned long task_entry; //进程入口点 char stack[STACK_SIZE]; volatile long state; struct Thread thread; struct PCB *next;&#125;; 运行一个进程基本需要以下第三步： 创建0号进程： 123456789asm volatile( "movl %1,%%esp\n\t" "pushl %1\n\t" //将0号进程栈底指针压栈 "movl %1,%%ebp\n\t" "pushl %0\n\t" "ret\n\t" //启动0号进程 : :"c"(task[0].thread.ip),"d"(task[0].thread.sp)); 调度到一个尚未创建栈环境的进程x（即，创建子栈）： 1234567891011asm volatile( "pushl %%ebp\n\t" /*保存父栈环境*/ "movl %%esp,%0\n\t" "movl $1f,%1\n\t" "movl %2,%%ebp\n\t" /*新建子栈环境*/ "movl %2,%%esp\n\t" "pushl %3\n\t" /*启动x号进程*/ "ret\n\t" :"=m"(task[NOW]-&gt;thread.sp),"=m"(task[NOW]-&gt;thread.ip) :"m"(task[x]-&gt;thread.sp),"m"(task[x]-&gt;thread.ip)); 调度到已经存在栈环境（即，至少运行过一次）的进程x（即，切换栈环境）： 123456789101112asm volatile( "pushl %%ebp\n\t" /*保存父栈环境*/ "movl %%esp,%0\n\t" "movl $1f,%1\n\t" "movl %2,%%esp\n\t" /*切换栈环境*/ "pushl %3\n\t" /*切换至x号进程*/ "ret\n\t" "1:\t" //下条指令的地址即为$1f对应的地址 "popl %%ebp\n\t" //此处pop出的是上次x进程被切换出去时push进去的ebp :"=m"(task[NOW]-&gt;thread.sp),"=m"(task[NOW]-&gt;thread.ip) :"m"(task[x]-&gt;thread.sp),"m"(task[x]-&gt;thread.ip)); 结合以上三点，便可总结调度器切换进程的简要步骤（省略进程的优先级策略等）： 保存栈环境：进程断点压栈（编译器自动生成该指令），进程栈底指针压栈，保存进程栈顶指针，并保存恢复栈环境指令的首地址$1f。 转移栈环境：给栈顶指针赋值，并弹出新进程栈底指针和断点。 假设可执行文件是静态链接的（不考虑共享库），实例一个程序只需将程序的文本段、数据段、bss段和堆栈段映射到进程线性区，然后结合上述的第二点，调度到这个尚未创建栈环境的进程，之后只运行上述的第三点即可，从而便实现了对一个程序的实例化。 附：fork()返回两次的本质待续 refernece0: C语言ASM汇编内嵌语法zz reference1: linux内核分析]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim-使用教程]]></title>
    <url>%2F2017%2F05%2F05%2Fvim-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vim 插件配置安装vim123456$ git clone git@github.com:vim/vim.git$ cd vim/$ sudo apt install python-dev python3-dev ruby-dev libtolua-dev libx11-dev libghc-gtk-dev libghc-gtk3-dev python-gtk2-dev libghc-ncurses-dev$ ./configure --with-features=huge --enable-pythoninterp --enable-rubyinterp --enable-luainterp --enable-perlinterp --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu/ --enable-gui=gtk2 --enable-cscope --prefix=/usr$ make$ make install more infoUbuntu Packages Search 安装 vundle1$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim .vimrc 文件配置参考 .vimrc 安装插件进入vim执行：123:PluginInstall:PluginClean #卸载前先删掉.vimrc文件中的配置语句:PluginUpdate 安装YCM插件1234$ sudo apt-get install llvm-dev clang$ sudo apt install cmake$ cd ~/.vim/bundle/YouCompleteMe$ ./install.py --clang-completer --system-libclang more infouse vim as IDE gvim 的使用工程环境配置修改~/.indexer_files 用于产生标签 123--------------- ~/.indexer_files --------------- [project] /home/redmud/practice/project/src/ 根据你工程情况只需调整 .ycm_extra_conf.py 的 flags 部分 参考.ycm_extra_conf.py 快捷键的使用1234567891011121314151617181920212223242526;ilt #打开标签页;hw #跳转左侧窗口p #右侧窗口显示标签对应函数/word #在文件内查找关键字;sp #在工程内查找关键字&lt;CR&gt; #进入关键字对应文件p #暂时在右侧显示对应文件q #退出u #撤销上步操作 ctl+r #撤销上步的撤销;ud #显示撤销树;;fx #跳至x字符;cc #注释;cu #取消注释;rw #在文件内不确认得全文替换单词mx #设定/取消该行为标签xm, #自动设定一个可用书签名mn #跳转至下个书签mda #删除当前文件所有书签ctl+o #跳回上次鼠标位置]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 使用教程]]></title>
    <url>%2F2017%2F05%2F04%2Fgit-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[使用ssh背景 用作认证的私钥最好通过passphrase进行加密，否则会有很大安全隐患，只要私钥泄露，别人就能访问你能访问的所有远程机器，不过每次登陆都得输入passphrase。 ssh-agent启动后，可通过ssh-add将私钥加入agent，使用ssh-agent后，只需在将key纳入agent管理时输入passphrase，之后的ssh相关操作就不必输入passphrase了。如果ssh-agent中有多个私钥, 会依次尝试，直到认证通过或遍历所有私钥。 more infoSSH Agent Forwarding原理An Illustrated Guide to SSH Agent Forwarding 指令12345$ ssh-kengen -t rsa -C "some words(email usually)"$ ssh-agent -s$ ssh-add ~/.ssh/id-rsa #添加私钥$ ssh-add ~/.ssh/id-rsa2$ vim ~/.ssh/config config 文件类似如下123456789Host redmudbupt.github.com HostName github.com IdentityFile /home/redmud/.ssh/id_rsa User git host bkseastone.github.com HostName github.com IdentityFile /home/redmud/.ssh/id_rsa2 User git 应用123$ git remote add origin git@bkseastone.github.com:bkseastone/lab_test.git #添加远程库$ git config user.name "one_name" $ git config user.email "one_email" #给仓库设置局部用户名和邮箱 git 使用 more infogit command]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
